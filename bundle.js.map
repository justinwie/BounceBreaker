{"version":3,"sources":["webpack:///webpack/bootstrap 6ee51a1dcff80dd5aa41","webpack:///./lib/bouncebreaker.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,kBAAiB,sBAAsB;AACvC;AACA,oBAAmB,mBAAmB;AACtC,+BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,qBAAqB;AACxC;AACA,0BAAyB;AACzB;AACA,eAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc,2BAA2B;AACzC,iBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc,2BAA2B;AACzC,iBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,2BAA2B;AAC9C,sBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,cAAc;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc,2BAA2B;AACzC,iBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc,2BAA2B;AACzC,iBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW;AACX;AACA,YAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,wBAAuB,2BAA2B;AAClD,0BAAyB,8BAA8B;AACvD;AACA;AACA;;AAEA;;AAEA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC;;AAED;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 6ee51a1dcff80dd5aa41\n **/","document.addEventListener(\"DOMContentLoaded\", function(){\n  var canvas = document.getElementById(\"myCanvas\");\n    canvas.width = 480;\n    canvas.height = 320;\n\n  document.addEventListener(\"keydown\", keyDownHandler, false);\n  document.addEventListener(\"keyup\", keyUpHandler, false);\n\n  var ctx = canvas.getContext(\"2d\");\n\n  var x = canvas.width/2;\n  var y = canvas.height-10;\n\n  var lineX = canvas.width/2;\n  var lineY = 0;\n\n  var speedScale = 7;\n\n  var dx = (lineX - x)/(y - lineY) * speedScale;\n  var dy = -1 * speedScale;\n\n  var ballRadius = 10;\n\n  var rightPressed = false;\n  var leftPressed = false;\n  var spacePressed = false;\n\n  let startRound = 0;\n\n  var brickRowCount = 1;\n  var brickColumnCount = 6;\n  var brickWidth = 60;\n  var brickHeight = 30;\n  var brickPadding = 2;\n  var brickOffsetTop = 30;\n  // var brickOffsetLeft = 0;\n  var brickOffsetLeft = (canvas.width - ((brickWidth+(brickPadding))*brickColumnCount))/2;\n\n  var minNewBricks = 1;\n  var maxNewBricks = 6;\n\n  var score = 0;\n  var round = 1;\n\n  let newRound = false;\n\n  let randomNum = Math.floor(Math.random() * (maxNewBricks - minNewBricks + 1)) + minNewBricks;\n\n  let existingBricks = new Array(brickColumnCount);\n\n  for (var i = 0; i < brickColumnCount; i++) {\n    existingBricks[i] = [];\n    for (var j = 0; j < brickRowCount; j++) {\n      existingBricks[i][j] = { x: 0, y: 0, hit: 0, power: round };\n    }\n  };\n\n  let newBricks = [];\n  function createNewBricks(){\n    let randomNumBricks = Math.floor(Math.random() * (maxNewBricks - minNewBricks + 1)) + minNewBricks;\n    for (var i = 0; i < randomNumBricks; i++) {\n      newBricks[i] = [];\n      newBricks[i][0] = { x: 0, y: 0, hit: 0, power: round };\n    };\n    for(i = 0; i < newBricks.length; i++) {\n      var brickX = (i*(brickWidth+brickPadding))+brickOffsetLeft;\n      var brickY = brickOffsetTop\n      newBricks[i][0].x = brickX;\n      newBricks[i][0].y = brickY;\n    }\n  }\n\n  function keyDownHandler(e) {\n    if(e.keyCode === 39) {\n      rightPressed = true;\n    }\n    else if(e.keyCode === 37) {\n      leftPressed = true;\n    }\n    else if(e.keyCode === 32) {\n      spacePressed = true;\n    }\n  }\n\n  function keyUpHandler(e) {\n    if(e.keyCode === 39) {\n      rightPressed = false;\n    }\n    else if(e.keyCode === 37) {\n      leftPressed = false;\n    }\n    else if(e.keyCode === 32) {\n      spacePressed = false;\n    }\n  }\n\n  function collisionDetection(){\n    for(i = 0; i < existingBricks.length; i++) {\n      for(j = 0; j < existingBricks[i].length; j++) {\n        let existingBrick = existingBricks[i][j];\n        // if(existingBrick.hit === 0){\n        if(existingBrick.power > 0){\n          if((y+ballRadius/2 > existingBrick.y) && (y-ballRadius/2 < (existingBrick.y+brickHeight)) && (x+ballRadius/2 > existingBrick.x) && (x-ballRadius/2 < (existingBrick.x + brickWidth))){\n          // if((y > existingBrick.y) && (y < (existingBrick.y+brickHeight)) && (x > existingBrick.x) && (x < (existingBrick.x + brickWidth))){\n          // if((y+ballRadius > existingBrick.y-brickHeight) && (y-ballRadius < (existingBrick.y+brickHeight)) && (x+ballRadius > existingBrick.x-brickWidth) && (x-ballRadius < (existingBrick.x + brickWidth))){\n            // if (Math.random()>0) {\n            //   dx = -dx;\n            // }\n            existingBrick.power -= 1;\n            if (Math.random()>0.95) {\n              dx *= 1.1;\n            }\n            dy = -dy;\n            // existingBrick.hit = 1;\n            score++;\n          }\n        }\n      }\n    }\n  }\n\n  function checkIfLost(){\n    for(i = 0; i < existingBricks.length; i++) {\n      for(j = 0; j < existingBricks[i].length; j++) {\n        var brick = existingBricks[i][j];\n        // if(brick.hit === 0){\n        if(brick.power > 0){\n          if(brick.y > canvas.height-brickHeight){\n            alert(\"GAME OVER\");\n            document.location.reload();\n          }\n        }\n      }\n    }\n  }\n\n  // function animateBricks(duration){\n  //   // let accel = 5;\n  //   // const brickDy = 50 + accel;\n  //   // let start = new Date().getTime();\n  //   // let end = start + duration;\n  //\n  //   let animation = function(){\n  //     for(i = 0; i < existingBricks.length; i++) {\n  //       for(j = 0; j < existingBricks[i].length; j++) {\n  //         if(existingBricks[i][j].hit === 0){\n  //           ctx.beginPath();\n  //           ctx.rect(existingBricks[i][j].x, existingBricks[i][j].y, brickWidth, brickHeight);\n  //           ctx.fillStyle = \"Purple\";\n  //           ctx.fill();\n  //           ctx.closePath();\n  //         }\n  //       }\n  //     }\n  //\n  //     let animate = true;\n  //     if (animate) requestAnimationFrame(animation)\n  //   }\n  //\n  //   setTimeout(function(){ animation() }, 1)\n  //   let animate = false\n  // }\n\n  function drawArrow(){\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.lineTo(lineX, lineY);\n    ctx.stroke();\n  }\n\n  function drawBall(){\n    ctx.beginPath();\n    ctx.arc(x, y, ballRadius, 0, Math.PI*2);\n    ctx.fillStyle = \"Green\";\n    ctx.fill();\n    ctx.closePath();\n  }\n\n  function createInitialBricks(){\n    for(i = 0; i < existingBricks.length; i++) {\n      for(j = 0; j < existingBricks[i].length; j++) {\n        // if(existingBricks[i][j].hit === 0){\n        if(existingBricks[i][j].power > 0){\n            var brickX = (i*(brickWidth+brickPadding))+brickOffsetLeft;\n            var brickY = (j*(brickHeight+brickPadding))+brickOffsetTop;\n            existingBricks[i][j].x = brickX;\n            existingBricks[i][j].y = brickY;\n        }\n      }\n    }\n  }\n\n  function drawBricks() {\n    for(i = 0; i < existingBricks.length; i++) {\n      for(j = 0; j < existingBricks[i].length; j++) {\n        // if(existingBricks[i][j].hit === 0){\n        if(existingBricks[i][j].power > 0){\n          ctx.beginPath();\n          ctx.rect(existingBricks[i][j].x, existingBricks[i][j].y, brickWidth, brickHeight);\n\n          if (existingBricks[i][j].power > 5 && existingBricks[i][j].power < 10) {\n            ctx.fillStyle = \"Orange\";\n          }else if (existingBricks[i][j].power > 10) {\n            ctx.fillStyle = \"Red\";\n          } else {\n            ctx.fillStyle = \"Blue\";\n          }\n          ctx.fill();\n          ctx.closePath();\n\n          ctx.font = \"14px Arial\";\n          ctx.fillStyle = \"White\";\n          ctx.fillText(existingBricks[i][j].power, existingBricks[i][j].x+brickWidth/2-brickPadding*2, existingBricks[i][j].y+brickPadding*2+brickHeight/2);\n        }\n      }\n    }\n  }\n\n  function drawScore(){\n    ctx.font = \"16px Arial\";\n    ctx.fillStyle = \"#0095DD\";\n    ctx.fillText(\"Score: \"+score, 8, 20);\n  }\n\n  function drawRound(){\n    ctx.font = \"14px Arial\";\n    ctx.fillStyle = \"Black\";\n    ctx.fillText(\"Round: \"+round, 8, 20);\n  }\n\n  function fillCanvas(){\n    ctx.rect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = \"lightgrey\";\n    ctx.fill();\n  }\n\n  function draw(){\n    fillCanvas()\n    checkIfLost();\n\n    drawRound();\n    drawBricks();\n    drawBall();\n\n    if (startRound === 0) {\n      drawArrow();\n    }\n\n    collisionDetection();\n\n    if (startRound != 0) {\n      if(x + dx > (canvas.width-ballRadius) || (x + dx) < ballRadius) {\n        dx = -dx;\n      }\n      if((y + dy) < ballRadius) {\n        dy = -dy;\n      }\n      x += dx;\n      y += dy;\n\n      if(y + dy > canvas.height-(ballRadius)) {\n        round++;\n\n        lineX = x;\n        lineY = 0;\n\n        dx = (lineX - x)/(y - lineY) * speedScale;\n        dy = -1 * speedScale;\n\n        for (var i = 0; i < existingBricks.length; i++) {\n          for (var j = 0; j < existingBricks[i].length; j++) {\n            existingBricks[i][j].y += (brickWidth/2+brickPadding)\n          }\n        };\n\n        createNewBricks()\n\n        for (var i = 0; i < newBricks.length; i++) {\n          let randomCol = Math.floor(Math.random() * (5 - 0 + 1)) + 0;\n          newBricks[i][0].x = existingBricks[randomCol][0].x;\n          existingBricks[randomCol].unshift(newBricks[i][0])\n        }\n\n        newBricks = [];\n\n        startRound = 0;\n      }\n    }\n\n    if (rightPressed && startRound === 0) {\n      if (lineX < canvas.width) {\n        if (lineY === 0) {\n          lineX += 20\n        }\n        else{\n          lineY -= 20\n        }\n      }\n      else {\n        lineY += 20;\n      }\n\n      dx = (lineX - x)/(y - lineY) * speedScale;\n      dy = -1 * speedScale;\n    }\n\n    else if (leftPressed && startRound === 0) {\n      if (lineX > 0) {\n        if (lineY != 0) {\n          lineY -= 20\n        }\n        else {\n          lineX -= 20\n        }\n      }\n      else {\n        lineY += 20\n      }\n\n      dx = (lineX - x)/(y - lineY) * speedScale;\n      dy = -1 * speedScale;\n    }\n\n    if (spacePressed) {\n      startRound++;\n    }\n  }\n\n\n  function game(){\n    draw();\n    requestAnimationFrame(game);\n  }\n\n  createInitialBricks()\n  game();\n\n});\n\n// if (existingBricks[i][j].y > 150 && existingBricks[i][j].y < 230) {\n//   ctx.fillStyle = \"Orange\";\n// }else if (existingBricks[i][j].y > 230) {\n//   ctx.fillStyle = \"Red\";\n// } else {\n//   ctx.fillStyle = \"Blue\";\n// }\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/bouncebreaker.js\n ** module id = 0\n ** module chunks = 0\n **/"],"sourceRoot":""}